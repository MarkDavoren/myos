#include "stdtypes.h"
#include "stdio.h"
#include "x86.h"
#include "disk.h"
#include "utility.h"
#include "memdefs.h"
#include "string.h"
#include "mbr.h"
#include "alloc.h"
#include "vfs.h"

typedef void (*KernelStart)();

void testContentsLargeFileExt();
void testSubdirectoryFileExt();
void loadAndJumpToKernelExt();
void printFileExt(Handle fin);
int  validateFileExt(Handle fin);

Partition partitionTable[4];

void __attribute__((cdecl)) start(Uint16 bootDrive, void* pt)
{
    Bool ok;
    clearScreen();
    printf("Hello from Stage2. Boot drive = %x\n", bootDrive);

    heapInit(HEAP_ADDRESS, HEAP_SIZE);
    printHeap();

   // Copy partition table into a safe, known location
    Partition* pp = (Partition*)pt;
    for (int ii = 0; ii < 4; ++ii) {
        partitionTable[ii] = *(Partition*) pt;
        pt += sizeof(Partition);
    }
    printPartitionTable(partitionTable);

    vSetType(FAT);

    ok = vInitialize(bootDrive, partitionTable);

    testContentsLargeFileExt();
    testSubdirectoryFileExt();

    panic("Stop in main");
}

void testContentsLargeFileExt()
{
    Handle fin = vOpen("/8MB");
    if (fin == BAD_HANDLE) {
        panic("vOpen returned error");
    }
    printf("vOpen: fin = %u\n", fin);

    if (validateFileExt(fin) == 0x200000) {
        printf("SUCCESS!!\n");
    }

    vClose(fin);
}

void testSubdirectoryFileExt()
{
    const int BUFF_SIZE = 1024;
    char buff[BUFF_SIZE + 1];

    Handle fin = vOpen("/mydir/test2.txt");
    if (fin == BAD_HANDLE) {
        panic("vOpen returned error");
    }
    printf("vOpen: fin = %u\n", fin);

    if (vRead(fin, 10, buff) != 10) {
        printf("Couldn't read 10 characters :(\n");
    }

    if (memcmp(buff, "1234567890", 10) != 0) {
        printf("File contents not as expected\n");
    } else {
        printf("SUCCESS!!\n");
    }

    vClose(fin);   
}

void loadAndJumpToKernelExt()
{
    const int BUFF_SIZE = 1024;
    char buff[BUFF_SIZE];
   
    Handle fin = vOpen("/kernel.bin");
    if (fin == BAD_HANDLE) {
        panic("Failed to open kernel");
    }

    Uint8* kp = KERNEL_LOAD_ADDR;
    Uint32 count;
    while ((count = vRead(fin, BUFF_SIZE, buff)) > 0) {
        printf("Copying %x bytes from %p to %p\n", count, buff, kp);
        memcpy(kp, buff, count);
        kp += count;
    }

    vClose(fin);

    Uint8* pp = KERNEL_LOAD_ADDR;
    for (int ii = 0; ii < 16; ++ii) {
        printf("%x ", pp[ii]);
    }
    printf("\n");

    KernelStart kernelStart = (KernelStart) KERNEL_LOAD_ADDR;
    printf("Jumping to kernel at %p\n", kernelStart);
    kernelStart();
}

/*
 * Print the contents of the file
 */
void printFileExt(Handle fin)
{
    const int BUFF_SIZE = 1024;
    char buff[BUFF_SIZE + 1];

    printf("File contents:\n");
    Uint32 count;
    while ((count = vRead(fin, BUFF_SIZE, buff))) {
        buff[count] = '\0';
        printf("%s", buff);
    }
}

/*
 * Check that the contents of the file matches what is generated by
 *      perl -e 'print pack "L*", 0..0x1fffff' > root/8MB
 * which is the 32 bit numbers from 0 to 0x1fffff in binary format
 */
int validateFileExt(Handle fin)
{
    const int BUFF_SIZE = 97; // Use a very oddly sized buffer to cause deliberately poor alignment with blocks
    Uint32 buff[BUFF_SIZE];
    Uint32 index = 0;
    Uint32 countBytes;

    printf("buff = %p\n", buff);
    int timer = 0;
    while ((countBytes = vRead(fin, BUFF_SIZE * sizeof(Uint32), buff)) > 0) {
        Uint32 countInts = countBytes / sizeof(Uint32);
        for (int ii = 0; ii < countInts; ++ii) {
            if (buff[ii] != index + ii) {
                printf("File mismatch: index = %d (%#x), ii = %d (%#x), buff = %x\n", index, index, ii, ii, buff[ii]);
                breakpoint();
                return -1;
            }
        }
        index += countInts;
        if ((++timer % 1000) == 0) {
            printf(".");
        }
    }
    printf("Validated %d (%#x) integers\n", index, index);
    return index;
}
